import java.nio.file.Files
import java.nio.file.Paths
import java.security.MessageDigest
import java.text.SimpleDateFormat
import java.util.logging.Filter

apply plugin: 'groovy'

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath "org.liquibase.ext:liquibase-hibernate5:3.7"
        classpath "org.yaml:snakeyaml:1.24"
        classpath "org.postgresql:postgresql:42.2.5"
    }
}

repositories {
    mavenLocal()
    mavenCentral()
}

configurations { driver }

dependencies {
    // Declare a localGroovy() dependency, to use the Groovy library that ships with Gradle.
    compile localGroovy()
    driver "org.postgresql:postgresql:42.2.5"
    runtime "org.yaml:snakeyaml:1.24"
    runtime "org.liquibase.ext:liquibase-hibernate5:3.7"
}

URLClassLoader loader = GroovyObject.class.classLoader
configurations.driver.each {File file ->
    loader.addURL(file.toURL())
}

//### input parameters
def footerFromFileName= "fixtures.yaml"
def masterChangeLogFileHeader = "databaseChangeLog:"
def newChangelogPrefix = "\n  - include:\n      file: "
def myStartDayOfFirstSprint = "2017-09-29"


//### code
def mainResources=projectDir.toPath().relativize(sourceSets.main.resources.srcDirs.iterator().next().toPath()).toString()
println "mainResources: $mainResources"
def testResources=projectDir.toPath().relativize(sourceSets.test.resources.srcDirs.iterator().next().toPath()).toString()
println "testResources: $testResources"
def yamlLoader = new org.yaml.snakeyaml.Yaml();
def cfg = yamlLoader.loadAll(new File("${mainResources}/application.yml").newInputStream()).first()
def cfgDev = yamlLoader.loadAll(new File("${mainResources}/application-dev.yml").newInputStream()).first()
def cfgTest = yamlLoader.loadAll(new File("${testResources}/application-test.yml").newInputStream()).first()

def liquibaseReferenceURL = cfg.referenceUrl

def dbDevUsername = cfgDev.spring.datasource.username
def dbDevPassword = cfgDev.spring.datasource.password
def dbDevUrl = cfgDev.spring.datasource.url
def dbDevDriver = cfgDev.spring.datasource.'driver-class-name'

def dbUsername = cfgTest.spring.datasource.username
def dbPassword = cfgTest.spring.datasource.password
def dbUrl = cfgTest.spring.datasource.url

def dbDevReady = isDatabaseServerActive(dbDevUrl, dbDevUsername, dbDevPassword, dbDevDriver)
println "database DEV ${cfgDev.spring.datasource.url} is ready: ${dbDevReady}"

//output files
def currentBranch = getWorkingBranch()
print "\nCurrent branch: $currentBranch"
def sprintNumber = getSprintNumber(myStartDayOfFirstSprint)
def disabledBranches = ["integration", "qualification", "master"]
def isEabledBranch = ! disabledBranches.contains(currentBranch)
println ", task DIFF is enabled for this branch: ${isEabledBranch}"

def relativePath = "db/changelog"
def masterChangeLogFileRelativePath = cfg.spring.liquibase.get("change-log")
if (masterChangeLogFileRelativePath!=null && !masterChangeLogFileRelativePath.toString().trim().isEmpty()) {
    masterChangeLogFileRelativePath = masterChangeLogFileRelativePath.toString().replace("classpath:", "${mainResources}/")
    relativePath=Paths.get("$projectDir/${mainResources}/").relativize(Paths.get("$projectDir/$masterChangeLogFileRelativePath").getParent()).toString()
} else {
    masterChangeLogFileRelativePath = "${mainResources}/${relativePath}/db.changelog-master.yaml"
}
relativePath += "/generated"
println "changelog files relativePath: $relativePath"
Files.createDirectories(Paths.get("$projectDir/${mainResources}/${relativePath}/"))

def masterChangeLogFile = "$projectDir/$masterChangeLogFileRelativePath"
println "master changelog file: $masterChangeLogFile"
if (!(new File(masterChangeLogFile)).exists()) {
    println 'diffChangeLog: master changelog file not existed, create it.'
    new File(masterChangeLogFile).text = masterChangeLogFileHeader
}
def masterChangeLog = yamlLoader.loadAll(new File(masterChangeLogFileRelativePath).newInputStream()).first()
def masterChangeLogIncludes = masterChangeLog.databaseChangeLog.include.file
//println "masterChangeLogIncludes: $masterChangeLogIncludes"
def masterChangeLogIncludesSize = masterChangeLogIncludes==null ? 0 : masterChangeLogIncludes.size()
//println "masterChangeLogIncludesSize: $masterChangeLogIncludesSize"

def fileMainName = "sprint-${sprintNumber}-${currentBranch}"
def fileName = fileMainName+"-"+md5(fileMainName)+".yaml"
def sprintChangeLogRelativePath = "${relativePath}/${fileName}"
def sprintDiffChangeLogFile     = "$projectDir/${mainResources}/${sprintChangeLogRelativePath}"

def sprintFile = new File(sprintDiffChangeLogFile)
def oldChangesMd5=null;
if (sprintFile.exists()) {
    def oldChanges = getChanges(sprintFile)
    oldChangesMd5 = md5(oldChanges)
    def declaredChangesMd5 = getDeclaredChangesMd5(sprintFile)
    def specialLiquibaseCommands=["renametable","renameview","renamecolumn","mergecolumns","modifydatatype","insert","update","delete"]
    def containSpecialLiquibaseCommands = containSpecialLiquibaseCommands(specialLiquibaseCommands, sprintFile)
    if (oldChangesMd5 != declaredChangesMd5 && containSpecialLiquibaseCommands) {
        fileName = fileMainName+"-"+md5(fileMainName)+"-generated.yaml"
        println "the file ${sprintFile} existed but has been modified manually and contains special liquibase command ${specialLiquibaseCommands}, so its content can not be override, the new file will use another name ${fileName}"
        sprintChangeLogRelativePath = "${relativePath}/${fileName}"
        sprintDiffChangeLogFile     = "$projectDir/${mainResources}/${sprintChangeLogRelativePath}"
        sprintFile = new File(sprintDiffChangeLogFile)
    }
}

def sprintDiffChangeLogFileTemp = "$projectDir/${mainResources}/${relativePath}/tmp.yaml"
def sprintDiffChangeLogBuildDir = "$buildDir/resources/main/${relativePath}"
def sprintDiffChangeLogBuildDirFile = "$sprintDiffChangeLogBuildDir/${fileName}"
def sprintDiffChangeLogBuildDirFileExisted = (new File(sprintDiffChangeLogBuildDirFile)).exists()

//### take account of the special changelog "footers" or "referencials"
def footerFromFileNameIndex = null
for (int i=0; i< masterChangeLogIncludesSize; i++) {
    if (masterChangeLogIncludes[i].endsWith("/$footerFromFileName")) {
        footerFromFileNameIndex = i
    }
}
println "masterChangeLogIncludesSize all: $masterChangeLogIncludesSize"

def footersChangelogFileRelativePath = null
if (footerFromFileNameIndex!=null) {
    masterChangeLogIncludesSize = footerFromFileNameIndex
    footersChangelogFileRelativePath = "${mainResources}/"+masterChangeLogIncludes[footerFromFileNameIndex]
}
println "masterChangeLogIncludesSize until footers(exclude): $masterChangeLogIncludesSize"
println "footer changelogs start from index $footerFromFileNameIndex, file: " + footersChangelogFileRelativePath

//### get previews changelog file
def previewsChangeLogFile=null
if (masterChangeLogIncludesSize>0) {
    previewsChangeLogFile = masterChangeLogIncludes[masterChangeLogIncludesSize-1]
    if (previewsChangeLogFile==sprintChangeLogRelativePath) {
        if (masterChangeLogIncludesSize>1) {
            previewsChangeLogFile = masterChangeLogIncludes[masterChangeLogIncludesSize-2]
        } else {
            previewsChangeLogFile = null
        }
    }
}

print "\npreviews changelog file: ${previewsChangeLogFile}"
def previewsChangelogFileApplied = dbDevReady && isChangelogApplied(dbUrl, dbUsername, dbPassword, dbDevDriver, previewsChangeLogFile)
print ", applied: $previewsChangelogFileApplied\n"

//### get last applied changelog file (not footers)
def allAppliedChangelogFileNames = dbDevReady ? getAllAppliedChangelogFileNames(dbUrl, dbUsername, dbPassword, dbDevDriver) : null
def allAppliedChangelogFileNamesSize = allAppliedChangelogFileNames==null ? 0 : allAppliedChangelogFileNames.size()
println "the number of all applied changelogs: $allAppliedChangelogFileNamesSize"

def allAppliedChangelogFileNamesBeforeFooters = allAppliedChangelogFileNames
def changelogFileNamesAfterFooters = new HashSet()
if (footerFromFileNameIndex!=null) {
    changelogFileNamesAfterFooters.addAll( masterChangeLogIncludes[footerFromFileNameIndex..(masterChangeLogIncludes.size()-1)] )

    if (footerFromFileName.endsWith(".yaml") || footerFromFileName.endsWith(".yml")) {
        def footersChangelogFile = "$projectDir/$footersChangelogFileRelativePath"
        println "footer changelogs start from file absolute path: $footersChangelogFile"
        if ((new File(footersChangelogFile)).exists()) {
            def footersChangeLog = yamlLoader.loadAll(new File(footersChangelogFileRelativePath).newInputStream()).first()
            def footersChangeLogIncludes = footersChangeLog.databaseChangeLog.include.file
            changelogFileNamesAfterFooters.addAll( footersChangeLogIncludes )
        }
    }
}
if (allAppliedChangelogFileNamesBeforeFooters!=null) {
    // changelogFileNamesAfterFooters.each {println it}
    allAppliedChangelogFileNamesBeforeFooters.removeIf {  changelogFileNamesAfterFooters.contains(it.trim()) }
    println "the number of applied changelogs before footer: " + allAppliedChangelogFileNamesBeforeFooters.size()
    // allAppliedChangelogFileNamesBeforeFooters.each{ println it }
}

def lastAppliedChangelogFileName = allAppliedChangelogFileNamesBeforeFooters==null || allAppliedChangelogFileNamesBeforeFooters.size()==0 ? null : allAppliedChangelogFileNamesBeforeFooters[-1]
print "\nlast applied changelog: $lastAppliedChangelogFileName"
def lastAppliedChangelogFileNameInMasterIncludes =
        lastAppliedChangelogFileName!=null && !lastAppliedChangelogFileName.trim().isEmpty() && masterChangeLogIncludesSize>0 ? masterChangeLogIncludes.contains(lastAppliedChangelogFileName.trim()) : false
print ", in current master: $lastAppliedChangelogFileNameInMasterIncludes\n"

//### get current changelog file name
print "\ncurrent changelog file: ${sprintChangeLogRelativePath}"
def currentChangelogFileApplied = sprintDiffChangeLogBuildDirFileExisted && dbDevReady && isChangelogApplied(dbUrl, dbUsername, dbPassword, dbDevDriver, sprintChangeLogRelativePath)
print ", applied: $currentChangelogFileApplied\n"

def emptyChangelog = 'databaseChangeLog: []'

def argsTest = ["--changeLogFile="+masterChangeLogFile, "--username="+dbUsername, "--password="+dbPassword, "--url="+dbUrl,
                "--referenceUrl="+liquibaseReferenceURL, "--referenceDriver=liquibase.ext.hibernate.database.connection.HibernateDriver"]
def argsDev = ["--changeLogFile="+masterChangeLogFile, "--username="+dbDevUsername, "--password="+dbDevPassword, "--url="+dbDevUrl,
               "--referenceUrl="+liquibaseReferenceURL, "--referenceDriver=liquibase.ext.hibernate.database.connection.HibernateDriver"]

task dropAll(type: JavaExec) {
    enabled = isEabledBranch && dbDevReady && (currentChangelogFileApplied || !lastAppliedChangelogFileNameInMasterIncludes)
    classpath sourceSets.main.runtimeClasspath
    main = "liquibase.integration.commandline.Main"
    args = argsTest + "dropAll"
}

task update(type: JavaExec, dependsOn: 'dropAll') {
    doFirst {
        def sprintFileBuildDir = new File(sprintDiffChangeLogBuildDirFile)
        if (sprintFileBuildDir.exists()) {
            println "update: clear ${sprintFileBuildDir}"
            sprintFileBuildDir.text = emptyChangelog
        }
    }

    enabled = isEabledBranch && dbDevReady && (!previewsChangelogFileApplied || currentChangelogFileApplied || !lastAppliedChangelogFileNameInMasterIncludes)
    classpath sourceSets.main.runtimeClasspath
    main = "liquibase.integration.commandline.Main"
    args = argsTest + "update"
}

task diffChangeLog(type: JavaExec, dependsOn: 'update') {
    enabled = isEabledBranch && dbDevReady
    classpath sourceSets.main.runtimeClasspath
    main = "liquibase.integration.commandline.Main"
    args = argsTest + "--changeLogFile=${sprintDiffChangeLogFileTemp}" + "diffChangeLog"
    //logging.captureStandardOutput LogLevel.INFO
    standardOutput new LogOutputStream(logger, LogLevel.INFO)
    errorOutput    new LogOutputStream(logger, LogLevel.INFO)

    doLast {
        println 'diffChangeLog: doLast'
        def sprintFileTemp = new File(sprintDiffChangeLogFileTemp)
        def masterFile = new File(masterChangeLogFile)

        def foundChanges = ! sprintFileTemp.text.startsWith(emptyChangelog)
        if (foundChanges) {
            println 'diffChangeLog: found changes.'

            def newChanges=getChanges(sprintFileTemp)
            def newChangesMd5=md5(newChanges)
            sprintFileTemp.text = "changesMd5: "+newChangesMd5+"\n"+sprintFileTemp.text

            if (sprintFile.exists()) {
                if (oldChangesMd5==newChangesMd5) {
                    println 'diffChangeLog: file existed but with the same content, not need to update content.'
                } else {
                    println 'diffChangeLog: file existed and not the same content, update content.'
                    sprintFile.text = sprintFileTemp.text
                    println (currentChangelogFileApplied ? "diffChangeLog: recreate db dev because of one existed changelog has been modified and applied in database" : "diffChangeLog: not need to recreate db dev")
                    diff.enabled = true
                }
                println 'diffChangeLog: delete temp file.'
                sprintFileTemp.delete()
            } else {
                println 'diffChangeLog: file not existed, create it.'
                sprintFileTemp.renameTo(sprintFile)
                println 'diffChangeLog: append created file to master change log file.'
                def newChangelog = "${newChangelogPrefix}${sprintChangeLogRelativePath}"
                if (footerFromFileNameIndex!=null) {
                    if (previewsChangeLogFile!=null) {
                        masterFile.text = masterFile.text.replace(previewsChangeLogFile , previewsChangeLogFile + newChangelog )
                    } else {
                        masterFile.text = masterFile.text.replaceAll(masterChangeLogFileHeader , masterChangeLogFileHeader + newChangelog )
                    }
                } else {
                    masterFile.text = masterFile.text + newChangelog
                }

                addToGitIndex("$mainResources/$sprintChangeLogRelativePath")
            }

        } else {
            sprintFileTemp.delete()
            println 'diffChangeLog: no changes found, delete temp file.'
        }
    }
}

task diff(type: JavaExec, dependsOn: 'diffChangeLog') {
    enabled = false
    classpath sourceSets.main.runtimeClasspath
    main = "liquibase.integration.commandline.Main"
    args = argsDev + "dropAll"
}

task reset(type: JavaExec, dependsOn: 'dropAll') {
    doFirst {
        if (sprintFile.exists()) {
            println "reset: clear ${sprintFile}"
            sprintFile.text = emptyChangelog
        }
    }

    enabled = isEabledBranch && dbDevReady
    classpath sourceSets.main.runtimeClasspath
    main = "liquibase.integration.commandline.Main"
    args = argsDev + "dropAll"
}

/**
 * add the file to git index use command git add
 * @param file
 * @return
 */
def addToGitIndex(file) {
    // Triple double-quotes for the breaklines
    def gitAdd = """git --git-dir=${rootDir}/../.git
                               --work-tree=${rootDir}/..
                               add ${file}"""
    // println "gitAdd: "+gitAdd
    gitAdd.execute()
}

/**
 * Get the name of the working branch of the project
 *
 * @return Name of the working branch
 */
def getWorkingBranch() {
    // Triple double-quotes for the breaklines
    def workingBranch = """git rev-parse --abbrev-ref HEAD""".execute().text.trim().replace('/','-')
    if (!workingBranch || workingBranch.trim().isEmpty()) workingBranch="init"
    return workingBranch
}

int getSprintNumber(startDayOfFirstSprint) { // 2018-05-10 15; 2018-05-11 16
    use(groovy.time.TimeCategory) {
        def duration = new Date() - new SimpleDateFormat("yyyy-MM-dd").parse(startDayOfFirstSprint)
        int sprintNumber = duration.days/14
        // println "sprintNumber: ${sprintNumber}"
        return sprintNumber
    }
}

boolean isDatabaseServerActive(url, user, password, driver) {
    def request = 'select 1'
    def row= querySingle(url, user, password, driver, request, true)
    return row != null
}

boolean isChangelogApplied(url, user, password, driver, changelogFile) {
    def request = 'SELECT count(*)>0 as applied FROM public.databasechangelog WHERE filename=\'' + changelogFile + '\''
    def row= querySingle(url, user, password, driver, request)
    return row==null ? false : row.applied
}

def getAllAppliedChangelogFileNames(url, user, password, driver){
    def request = 'SELECT filename FROM public.databasechangelog ORDER BY orderexecuted'
    def rows = query(url, user, password, driver, request)
    return rows==null ? [] : rows.filename
}

def query(url, user, password, driver, request, showError = false) {
    def sql
    try {
        groovy.sql.Sql.LOG.level = java.util.logging.Level.OFF
        groovy.sql.Sql.LOG.setFilter({false} as Filter)
        sql = groovy.sql.Sql.newInstance( url+"&loggerLevel=OFF", user, password, driver)
        //println "request: $request"
        return sql.rows(request)
    } catch (Exception e) {
        if (showError)
            println ("______________________ !!! DB Connection error: " + e.toString() )
        return null
    } finally {
        if (sql!=null) {
            sql.close()
        }
    }
}

def querySingle(url, user, password, driver, request, showError = false) {
    def sql
    try {
        groovy.sql.Sql.LOG.level = java.util.logging.Level.OFF
        groovy.sql.Sql.LOG.setFilter({false} as Filter)
        sql = groovy.sql.Sql.newInstance( url+"&loggerLevel=OFF", user, password, driver)
        //println "request: $request"
        return sql.firstRow(request)
    } catch (Exception e) {
        if (showError)
            println ("______________________ !!! DB Connection error: " + e.toString() )
        return null
    } finally {
        if (sql!=null) {
            sql.close()
        }
    }
}

String getChanges(file) {
    //println "file: $file"
    if (file==null || !file.exists()) return null;
    def yamlLoader = new org.yaml.snakeyaml.Yaml();
    def content = yamlLoader.load(file.newInputStream())
    def databaseChangeLog=content?.databaseChangeLog
    if (databaseChangeLog==null) return null;
    def changeSets = databaseChangeLog?.changeSet
    if (changeSets==null) return null;
    def changes=changeSets?.changes
    if (changes!=null) changes=changes.toString().replaceAll("\\s", "")
    //println "changes: $changes"
    return changes
    //return new File(filepath).filterLine { !(it =~ /^\s+(id):\s*[0-9-]+$/ || ) }
}

String md5(str) {
    if (str==null) return "";
    return MessageDigest.getInstance("MD5").digest(str.bytes).encodeHex().toString()
}

String getDeclaredChangesMd5(file) {
    if (file==null || !file.exists()) return null;
    def yamlLoader = new org.yaml.snakeyaml.Yaml();
    def content = yamlLoader.load(file.newInputStream())
    def changesMd5=content?.changesMd5
    if (changesMd5!=null) changesMd5=changesMd5.trim()
    return changesMd5
}

boolean containSpecialLiquibaseCommands(specialLiquibaseCommands, file) {
    if (file==null || !file.exists()) return null;
    def yamlLoader = new org.yaml.snakeyaml.Yaml();
    def content = yamlLoader.load(file.newInputStream())
    def databaseChangeLog=content?.databaseChangeLog
    if (databaseChangeLog==null) return null;
    def changeSets = databaseChangeLog?.changeSet
    if (changeSets==null) return null;
    List changes=changeSets?.changes
    if (changes==null) return false

    def keys = new HashSet();
    changes.each {
        if (it!=null && it.get(0)!=null) {
            Map change=it.get(0)
            if (change!=null) keys.addAll(change.keySet())
        }
    }
    return keys.any{specialLiquibaseCommands.contains(it.toString().toLowerCase())}
}

class LogOutputStream extends ByteArrayOutputStream {

    private final Logger logger;
    private final LogLevel level;

    LogOutputStream(Logger logger, LogLevel level) {
        this.logger = logger;
        this.level = level;
    }

    @Override
    void flush() {
        logger.log(level, toString());
        reset();
    }
}